# 锁

## 概念
- 自旋锁，当获取不到锁的时候，会一直循环尝试获取，不会产生上下文切换，通过CAS 指令实现
- 互斥锁，当获取失败时，会让渡CPU 使用，不会产生额外的消耗
- 可重入，两个都加了锁的方法，存在调用关系时，外层方法获取到锁之后，执行内层方法时，会自动获取到锁
- 读写锁，允许多个读锁同时获取到，但对写锁互斥；写锁对其他锁互斥
- 悲观锁和乐观锁，这其实是一种并发同步的策略，而不是具体的锁
  - 悲观锁，对于并发采取的是悲观的态度，不锁定资源，就一定会出错。synchronize 和 lock 就属于这种锁
  - 乐观锁，不加锁的并发操作也不会存在问题，对同一数据的并发操作是不会发生修改的，CAS 属于这种，乐观锁在高并发的情况下存在`ABA`的问题
 - 偏向锁、轻量级锁、重量级锁，偏向锁指一段同步代码被一个线程访问时，会自动获取锁；
    - 轻量级锁的膨胀过程，通过在当前对象的内存上设置线程ID ，其他线程访问这段代码时，通过线程ID做比较，如果不一致，在全局安全点时，偏向锁有可能升级成轻量级锁；
    - 当需要升级成轻量级锁时，在当前帧上建立 lock-record ，将对象上的mark-word-record 复制过来后，并修改mark word record 为lock-record 的地址；释放轻量级锁的时候，这里就存在回写的过程
## java 中锁机制
## 锁的内存语义
锁的释放过程，就是线程A 通过内存写入volatile 的过程；锁的获取过程，线程B 通过内存读取到valatile 值的过程

### 底层实现机制-AQS
### Synchronize 的锁提升机制
偏向锁-> 轻量级锁-> 重量级锁

```-XX:-UseBiasedLocking //关闭偏向锁（默认打开）``` 或者 ```-XX:+UseHeavyMonitors  //设置重量级锁```
### ReentrantReadWriteLock
