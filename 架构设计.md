# 架构设计漫谈
## 复杂性
## 微服务设计原则
### 数据设计原则
### 数据集成规范
### rest api 设计规范
### 领域驱动架构设计
## 云原生设计原则
## 高并发、高可用、高扩展特性
### 高并发的处理
1. http 流量分流
  - 硬件分流：采用 F5 的硬负载、LVS软负载实现负荷分担，横向扩展到多台Ngnix 上
  - 在硬件分流之前，可以通过DNS 按地域访问最近的数据中心，进一步分流处理
  - 通过F5 接入流量之后，F5 横向扩展到不同的Ngnix 服务器上，Ngnix 在将流量符合分担到不同的web 服务器
  - 针对静态资源，可以采用不同域名来做分流。
单机LVS 可以实现几十万的并发，F5 的性能比LVS更高,针对LVS 的单点问题，可以通过`keepAlived`组件解决
在业界落地实现中，又有具体的实现策略。
1. 阿里双11 的流量均衡。通过高性能的流量负载均衡器（依赖DPDK 技术）
2. 微信的红包 通过SET 化部署，实现应用的横向扩展、同时避免锁的使用。该项技术在美团也有使用，[美团点评SET 化部署使用](https://www.infoq.cn/article/edktgbzgi9q13dczo50a)；但该项技术使用成本比较高，可以针对核心功能采用
3. 面向未来的Service Mesh下Istio 负载均衡。后续研究

2. 网络层模型选择
  1.IO 多路复用（NIO）。tomcat 以及netty 都已经采用了 NIO + worker线程池的网络模型，处理底层网络流量。NIO 模型比较适合大量闲置的网络端口，网络处理性能上限会比较高
  2.受限于编程复杂性，不能全流程的采用NIO 模型，类似于`spring webflux` 只在网关这种对网络处理性能要求高、业务模型简单的场景，才会推荐使用
3. 应用架构设计
  - 应用架构设计过程中，需要通过消息队列解耦应用，非核心、强一致性的功能，比如查询可以通过其他组件进行承载。
  - 具体功能实现方案时，避免将所有流量焦点集中到单一组件上。比如分布式锁，可以采用`etcd`实现，而不采用数据库来实现
  - 应用组件选型，需要考虑高可用的方案，支持集群部署、热备等方案。同时，针对潜在的突发流量，支持无感的扩容设计
  - 缓存设计，这个是重点。可以考虑多级缓存，内存缓存+redis 缓存。而在落地过程中，需要考虑`缓存穿透`，`雪崩`、`一致性`等各种问题
  - 针对突发流量的治理，需要实现服务降级、转异步处理。或者天然使用消息机制，通过`削峰填谷`，实现应用的平滑处理
  - 在编程语言选择上，可以考虑采用`go`，这种高性能语言处理
## 一致性设计


